/*! For license information please see vendors~auth-msal-browser-1p.js.LICENSE.txt */
"use strict";(self.webpackChunkTypeScriptModule=self.webpackChunkTypeScriptModule||[]).push([["vendors~auth-msal-browser-1p"],{228678:(e,t,r)=>{r.r(t),r.d(t,{AccountEntity:()=>i.AccountEntity,ApiId:()=>i.ApiId,AuthError:()=>i.AuthError,AuthErrorCodes:()=>i.AuthErrorCodes,AuthErrorMessage:()=>i.AuthErrorMessage,AuthenticationHeaderParser:()=>i.AuthenticationHeaderParser,AuthenticationScheme:()=>i.AuthenticationScheme,AzureCloudInstance:()=>i.AzureCloudInstance,BrokerAuthError:()=>ue,BrokerAuthErrorCodes:()=>s,BrowserAuthError:()=>i.BrowserAuthError,BrowserAuthErrorCodes:()=>i.BrowserAuthErrorCodes,BrowserAuthErrorMessage:()=>i.BrowserAuthErrorMessage,BrowserCacheLocation:()=>i.BrowserCacheLocation,BrowserConfigurationAuthError:()=>i.BrowserConfigurationAuthError,BrowserConfigurationAuthErrorCodes:()=>i.BrowserConfigurationAuthErrorCodes,BrowserConfigurationAuthErrorMessage:()=>i.BrowserConfigurationAuthErrorMessage,BrowserPerformanceClient:()=>i.BrowserPerformanceClient,BrowserPerformanceMeasurement:()=>i.BrowserPerformanceMeasurement,BrowserUtils:()=>i.BrowserUtils,CacheLookupPolicy:()=>i.CacheLookupPolicy,ClientAuthError:()=>i.ClientAuthError,ClientAuthErrorCodes:()=>i.ClientAuthErrorCodes,ClientAuthErrorMessage:()=>i.ClientAuthErrorMessage,ClientConfigurationError:()=>i.ClientConfigurationError,ClientConfigurationErrorCodes:()=>i.ClientConfigurationErrorCodes,ClientConfigurationErrorMessage:()=>i.ClientConfigurationErrorMessage,DEFAULT_IFRAME_TIMEOUT_MS:()=>i.DEFAULT_IFRAME_TIMEOUT_MS,EventHandler:()=>i.EventHandler,EventMessageUtils:()=>i.EventMessageUtils,EventType:()=>i.EventType,InteractionRequiredAuthError:()=>i.InteractionRequiredAuthError,InteractionRequiredAuthErrorCodes:()=>i.InteractionRequiredAuthErrorCodes,InteractionRequiredAuthErrorMessage:()=>i.InteractionRequiredAuthErrorMessage,InteractionStatus:()=>i.InteractionStatus,InteractionType:()=>i.InteractionType,JsonWebTokenTypes:()=>i.JsonWebTokenTypes,LocalStorage:()=>i.LocalStorage,LogLevel:()=>i.LogLevel,Logger:()=>i.Logger,MemoryStorage:()=>i.MemoryStorage,NavigationClient:()=>i.NavigationClient,OIDC_DEFAULT_SCOPES:()=>i.OIDC_DEFAULT_SCOPES,PairwiseBrokerApplication:()=>De,PerformanceEvents:()=>i.PerformanceEvents,PromptValue:()=>i.PromptValue,ProtocolMode:()=>i.ProtocolMode,PublicClientApplication:()=>R,PublicClientNext:()=>i.PublicClientNext,ServerError:()=>i.ServerError,ServerResponseType:()=>i.ServerResponseType,SessionStorage:()=>i.SessionStorage,SignedHttpRequest:()=>i.SignedHttpRequest,StringUtils:()=>i.StringUtils,StubPerformanceClient:()=>i.StubPerformanceClient,UrlString:()=>i.UrlString,WrapperSKU:()=>i.WrapperSKU,createNestablePublicClientApplication:()=>i.createNestablePublicClientApplication,createStandardPublicClientApplication:()=>i.createStandardPublicClientApplication,isPlatformBrokerAvailable:()=>i.isPlatformBrokerAvailable,stubbedPublicClientApplication:()=>i.stubbedPublicClientApplication,version:()=>ve});var s={};r.r(s),r.d(s,{BrokerConnectionReset:()=>le,BrokerHandshakeFailed:()=>oe,BrokerHandshakeTimeout:()=>ne,BrokerPopupWillRedirect:()=>se,BrokerResponseInvalid:()=>re,BrokerTimeout:()=>ie,BrokeringDisabled:()=>de,NoTrustedBrokersProvided:()=>ae,ShrGenerationError:()=>ce});var i=r(599807),n=r(637282),o=r(13943),a=r(12338),d=r(739161),l=r(887440);const c={...r(285868).MX,PairwiseBrokerApplicationInitializeBrokering:"pairwiseBrokerApplicationInitializeBrokering",BrokerClientApplicationHandleBrokerHandshake:"brokerClientApplicationHandleBrokerHandshake",BrokerClientApplicationBrokeredSSOSilentRequest:"brokerClientApplicationBrokeredSSOSilentRequest",BrokerClientApplicationBrokeredSilentRequest:"brokerClientApplicationBrokeredSilentRequest",EmbeddedClientApplicationSendSSOSilentRequest:"embeddedSSOSilent",EmbeddedClientApplicationSendPopupRequest:"embeddedPopup",EmbeddedClientApplicationSendRedirectRequest:"embeddedRedirect",EmbeddedClientApplicationHandleRedirectRequest:"embeddedHandleRedirect",EmbeddedClientApplicationSendSilentRefreshRequest:"embeddedSilentRefresh",EmbeddedSendSilentRefreshRequestInternal:"embeddedSilentRefreshInternal",SendHandshakeRequest:"sendHandshakeRequest",SendMessageToBroker:"sendMessageToBroker",SendRequest:"sendRequest",HandleResponse:"handleBrokerResponse",GetFrameDepth:"getFrameDepth",OnHandshakeResponse:"onHandshakeResponse",HandleBrokerMessage:"handleBrokerMessage",PostMessageToAllDescendantFrames:"postMessageToAllDescendantFrames",HandleBrokerAuthRequest:"handleBrokerAuthRequest",BrokeredSilentRequest:"brokeredSilentRequest",BrokeredSsoSilentRequest:"brokeredSsoSilentRequest",BrokeredRedirectRequest:"brokeredRedirectRequest",BrokeredPopupRequest:"brokeredPopupRequest",InteractiveBrokerRequest:"interactiveBrokerRequest"},h=new Map([[c.PairwiseBrokerApplicationInitializeBrokering,"PWBInitBrk"],[c.BrokerClientApplicationHandleBrokerHandshake,"BrkClientHandeBrkHandshake"],[c.BrokerClientApplicationBrokeredSSOSilentRequest,"BrkClientBrkSSOReq"],[c.BrokerClientApplicationBrokeredSilentRequest,"BrkClientBrkSltReq"],[c.EmbeddedClientApplicationSendSSOSilentRequest,"EmbClientSendSSOReq"],[c.EmbeddedClientApplicationSendPopupRequest,"EmbClientSendPopupReq"],[c.EmbeddedClientApplicationSendRedirectRequest,"EmbClientSendRedirectReq"],[c.EmbeddedClientApplicationHandleRedirectRequest,"EmbClientHandleRedirectReq"],[c.EmbeddedClientApplicationSendSilentRefreshRequest,"EmbClientSendSltRefreshReq"],[c.SendHandshakeRequest,"sendHandshakeReq"],[c.SendMessageToBroker,"sendMsgToBrk"],[c.SendRequest,"sendReq"],[c.HandleResponse,"handleBrkRes"],[c.GetFrameDepth,"getFrameDepth"],[c.OnHandshakeResponse,"onHandshakeRes"],[c.HandleBrokerMessage,"handleBrkMsg"],[c.PostMessageToAllDescendantFrames,"postMsgToDescFrames"],[c.HandleBrokerAuthRequest,"handleBrkAuthReq"],[c.BrokeredSilentRequest,"brkSltReq"],[c.BrokeredSsoSilentRequest,"brkSsoSltReq"],[c.BrokeredRedirectRequest,"brkRedirectReq"],[c.BrokeredPopupRequest,"brkPopupSltReq"],[c.InteractiveBrokerRequest,"intBrkReq"]]),u=new Set(["brokerInteractionTimeoutMs","brokerMessageTimeoutMs","brokerHandshakeTimeoutMs","brokerIframeTimeoutMs","maxFrameDepthReached","maxFrameDepthConfigured","framesNotified","handshakeIgnoredCount","brokerFrameDepth","resolverKeyMissingCount","resolverKeyNotExistCount"]);var p=r(785292);const g="mats-telemetry-profile-id",m="PerformanceTelemetryReporter:";class k{constructor(e,t,r,s,i,n,o,a,d,c){this.appInsights=null,this.appInsightsPromise=null,this.synthetic=!1,this.observabilityRatio=.1,this.samplingRatio=.01,this.telemetryQueue=function(){const e=[],t=[];return{enqueue:t=>{e.push(t)},dequeue:()=>{if(0===t.length){let r=e.pop();for(;r;)t.push(r),r=e.pop()}return t.pop()},size:()=>e.length+t.length,clear:()=>{e.length=0,t.length=0}}}(),this.isProcessingQueue=!1,this.initializationRetries=0,this.telemetryDisabled=!1,this.clientId=e,this.logger=t,this.eventsToEmit=new Set(s),this.miscEvents=new Set(i),this.maxQueueSize=c?.maxQueueSize||1e3,this.maxRetries=c?.maxRetries||3,this.onOnInitializationFailure=c?.onInitializationFailure,this.appInsightsConfig={instrumentationKey:"d634483c08244c1ca09af2b2d952c92e-ab2bba03-2ba3-49d8-a82c-ef6da750d8ab-7725",extensions:[],propertyConfiguration:{gpcDataSharingOptIn:!1},disableCookiesUsage:!0},this.synthetic=o||!1,this.appName=a,this.appVersion=d,this.channelId=n,this.sampleEvents=Math.random()<=this.samplingRatio,this.logger.verbose(`Sampling for misc event enabled: ${this.sampleEvents}`);try{const e=new p.D(this.clientId,t,r),s=e.getItem(g);if(s)this.profileTelemetryId=s;else{const t=l.createGuid();this.profileTelemetryId=t,e.setItem(g,t)}}catch(e){t.warning(`${m} local storage is not available`),this.profileTelemetryId=""}this.logger.verbose(`${m} Initialized`)}async initializeAppInsights(){if(null!==this.appInsights)return this.appInsights;if(null!==this.appInsightsPromise)return this.appInsightsPromise;this.initializationRetries>=this.maxRetries&&(this.telemetryDisabled=!0,this.telemetryQueue.clear(),this.logger.warning(`${m} 1DS initialization failed after ${this.maxRetries} attempts. Telemetry disabled to prevent application issues.`),this.onOnInitializationFailure?.(new Error(`1DS initialization failed after ${this.maxRetries} attempts`))),this.appInsightsPromise=this.initAnalyticsDynamically();try{return this.appInsights=await this.appInsightsPromise,this.appInsights}catch(e){throw this.appInsightsPromise=null,this.initializationRetries++,this.onOnInitializationFailure?.(e instanceof Error?e:new Error(String(e))),e}}async initAnalyticsDynamically(){this.logger.verbose(`${m} Lazy loading and initializing 1DS`);try{const{ApplicationInsights:e}=await r.e("vendors-npm_store_sdx_officecopilot_microsoft-1ds-analytics-js_4_3_10-c04af46b54ae0b0c8d05_no-38c45a","high").then(r.bind(r,200890)),t=new e;return t.initialize(this.appInsightsConfig,[]),this.logger.verbose(`${m}: 1DS successfully loaded and initialized`),t}catch(e){const t=e instanceof Error?e.message:String(e);throw this.logger.error(`${m} Failed to load 1DS`,t),e}}sendCustomEvent(e){if(this.telemetryDisabled)return;if(!this.eventsToEmit.has(e.name))return void this.logger.verbose(`${m} Skipping telemetry for event ${e.name}`,e.correlationId);if(e.success&&!this.sampleEvents&&(this.miscEvents.has(e.name)||!0===e.fromCache))return void this.logger.verbose(`${m} Skipping telemetry for event ${e.name}`,e.correlationId);if(this.telemetryQueue.size()>=this.maxQueueSize)return void this.logger.warning(`${m} Queue size limit (${this.maxQueueSize}) reached. Dropping telemetry event ${e.name}.`);const t={...e,synthetic:this.synthetic,appName:this.appName,appVersion:this.appVersion,profileTelemetryId:this.profileTelemetryId,sessionId:this.channelId};var r;!e.success||(r=this.observabilityRatio,Math.random()<=r)?this.logger.verbose(`${m} Sending ${t.name} with additional observability for tracking`):(delete t.context,delete t.errorStack,this.logger.verbose(`${m} Sending ${t.name} for tracking`)),this.telemetryQueue.enqueue({name:e.name,data:t}),this.processQueueAsync().catch((t=>{const r=t instanceof Error?t.message:String(t);this.logger.warning(`${m} Failed to send telemetry for event ${e.name}: ${r}`)}))}async processQueueAsync(){if(!this.isProcessingQueue){this.isProcessingQueue=!0;try{const e=await this.initializeAppInsights();for(;this.telemetryQueue.size()>0;){const t=this.telemetryQueue.dequeue();t&&this.sendSingleEvent(e,t)}}finally{this.isProcessingQueue=!1}}}sendSingleEvent(e,t){e.track(t),t.name===c.AcquireTokenPreRedirect&&e.flush()}}const b=[c.InitializeClientApplication,c.LocalStorageUpdated],I=new Set([c.AcquireTokenSilent,c.AcquireTokenByCode,c.AcquireTokenPopup,c.AcquireTokenRedirect,c.AcquireTokenPreRedirect,c.PairwiseBrokerApplicationInitializeBrokering,c.SsoSilent,c.EmbeddedClientApplicationSendSSOSilentRequest,c.EmbeddedClientApplicationSendPopupRequest,c.EmbeddedClientApplicationSendRedirectRequest,c.EmbeddedClientApplicationHandleRedirectRequest,c.EmbeddedClientApplicationSendSilentRefreshRequest,...b]);class C{constructor(e,t,r,s,i){this.logger=t;const n=i?.eventsToEmit?.filter((e=>I?.has(e)))||[...I];this.perfTelemetryReporter=new k(e,t,r,n,b,s,i?.synthetic,i?.appName,i?.appVersion,i?.queueConfig)}sendCustomEvent(e){this.perfTelemetryReporter.sendCustomEvent(e)}async initializeAppInsights(){await this.perfTelemetryReporter.initializeAppInsights()}getTelemetryCallback(){this.logger.trace("TelemetryReporter: Attaching callback to send custom metrics.");return this.logger.verbose("TelemetryReporter: Returning callback as telemetry emitted."),e=>{e.forEach((e=>{e.name===c.AcquireTokenByBroker&&(e.name=e.brokerEventName||e.name,e.isBroker=!0,delete e.brokerEventName,this.logger.verbosePii(`TelemetryReporter: Updated broker event ${JSON.stringify(e)}`,e.correlationId)),this.sendCustomEvent(e)}))}}}const f=[n._.AzurePublic,n._.AzurePpe];class R extends o.vq{constructor(e,t){let r;const s="undefined"!=typeof window,i=!t?.disabled&&function(e){return!e.auth.authority||f.some((t=>0===e.auth.authority?.indexOf(t.toString())))}(e)&&s;if(i?(r=e.telemetry?.client||new a.S(e,new Set(u),new Map(h)),super({...e,telemetry:{...e.telemetry,client:r}})):(super(e),r=new d.a),this.performanceClient=r,this.channelId=s?l.createGuid():"",i){const s=new C(e.auth.clientId,this.getLogger(),r,this.channelId,t);this.addPerformanceCallback(s.getTelemetryCallback())}}static async createPublicClientApplication(e,t,r){const s=new R(e,t);return await s.initialize({correlationId:r}),s}}var S=r(466538),v=r(312982),B=r(585020),A=r(494030),w=r(642059);const E="BrokerReady",y="BrokerHandshakeRequest",T="BrokerHandshakeResponse",q="BrokerAuthRequest",M="BrokerRedirectResponse",P="BrokerHandleRedirectRequest",_="BrokerAuthResult",L="EmbeddedLogoutRequest",H="EmbeddedLogoutResponse",O="BrokerAuthError",N="InteractionRequiredAuthError",F="ServerError",U="ClientAuthError",D="ClientConfigurationError",$="BrowserAuthError",z="BrowserConfigurationError",X="AuthError";class x{constructor(e,t,r){this.messageType=e,this.channelId=t,this.messageId=r}static validateMessage(e){if(!e.data||!e.data.messageType)return null;switch(e.data.messageType){case y:case T:case P:case q:case _:case M:case L:case E:return e;default:return null}}}class Q extends x{constructor(e,t,r=!1,s,i,n){super(y,s,i),this.embeddedClientId=e,this.version=t,this.allowTelemetry=r,this.nonce=n}static validate(e){return e.data&&e.data.messageType===y&&e.data.embeddedClientId&&e.data.version?new Q(e.data.embeddedClientId,e.data.version,e.data.allowTelemetry,e.data.channelId||e.data.sessionId,e.data.messageId,e.data.nonce):null}}class K extends x{constructor(e,t,r,s,i){super(T,r,s),this.version=e,this.brokerOrigin=t,this.nonce=i}static validate(e,t){if(!t.includes(e.origin))return null;const r=x.validateMessage(e);return r&&r.data.messageType===T&&r.data.version?new K(r.data.version,r.origin,r.data.channelId||e.data.sessionId,r.data.messageId,r.data.nonce):null}}class G extends x{get embeddedAppOrigin(){return this._embeddedAppOrigin}constructor(e,t,r,s,i,n){super(q,i,n),this.embeddedClientId=e,this._embeddedAppOrigin=s,this.interactionType=t,this.request=r}static validate(e,t){return e.data&&e.data.messageType===q&&e.data.embeddedClientId&&e.data.interactionType&&e.data.request?new G(e.data.embeddedClientId,e.data.interactionType,e.data.request,t,e.data.channelId||e.data.sessionId,e.data.messageId):null}}class j extends x{constructor(e,t){super(M,e,t)}static validate(e){return e.data&&e.data.messageType===M?new j(e.data.channelId||e.data.sessionId,e.data.messageId):null}}var J=r(535367),V=r(949575),W=r(310617),Z=r(662443),Y=r(207712),ee=r(593130),te=r(505640);const re="broker_response_invalid",se="broker_popup_will_redirect",ie="broker_timeout",ne="broker_handshake_timeout",oe="broker_handshake_failed",ae="no_trusted_brokers_provided",de="brokering_disabled",le="broker_connection_reset",ce="shr_generation_error",he={[re]:"The broker response did not have the expected values.",[se]:"The request for a brokered popup requires a redirect by the broker. If your app does not perform the redirect, please check the broker's logs.",[ie]:"Message broker timed out.",[ne]:"Broker handshake response timed out.",[oe]:"Broker handshake failed. Please see logs for details.",[ae]:"No trusted brokers provided.",[de]:"Brokering is not enabled for the client application. Please check logs to see if handshake was performed.",[le]:"The broker connection was reset. Please retry the request.",[ce]:"Error generating SHRs. Kid is missing in the request."};class ue extends v.lR{constructor(e,t){super(e,t),Object.setPrototypeOf(this,ue.prototype),this.name=O}}function pe(e){return new ue(e,he[e])}class ge extends x{constructor(e,t,r,s,i){if(super(_,r,s),this.interactionType=e,this.result=t,i){const{setCorrelationId:e,...t}=i;this.errorPayload=t}}static validate(e){return e.data&&e.data.messageType===_&&e.data.interactionType&&(e.data.result||e.data.errorPayload)?new ge(e.data.interactionType,e.data.result,e.data.channelId||e.data.sessionId,e.data.messageId,e.data.errorPayload):null}static detectError(e){let t;switch(e.name){case N:t=new J.CB(e.errorCode,e.errorMessage,e.subError);break;case F:t=new V.g(e.errorCode,e.errorMessage,e.subError);break;case U:t=new W.eB(e.errorCode,e.errorMessage);break;case D:t=new Z.q5(e.errorCode);break;case $:t=new Y.jT(e.errorCode);break;case z:t=new ee.XX(e.errorCode,e.errorMessage);break;case O:t=new ue(e.errorCode,e.errorMessage);break;case X:t=new v.lR(e.errorCode,e.errorMessage,e.subError);break;default:t=new v.lR(te.unexpectedError,JSON.stringify(e))}return t.setCorrelationId(e.correlationId),t}}class me extends x{constructor(e,t,r,s){super(P,r,s),this.interactionType=B.X8.Redirect,this.embeddedClientId=e,this.version=t}static validate(e){return e.data&&e.data.messageType===P&&e.data.embeddedClientId&&e.data.version?new me(e.data.embeddedClientId,e.data.version,e.data.channelId||e.data.sessionId,e.data.messageId):null}}var ke=r(866520);function be(e){const t={preferredInteractionType:null,brokerRedirectParams:{},actAsBroker:!1,allowBrokering:!1,trustedBrokerDomains:[],brokerHandshakeTimeout:2e3,brokerMessageTimeout:ke.YH+5e3,brokerInteractionTimeout:3e5};return{preferredInteractionType:e?.preferredInteractionType||t.preferredInteractionType,brokerRedirectParams:e?.brokerRedirectParams||t.brokerRedirectParams,actAsBroker:e?.actAsBroker||t.actAsBroker,allowBrokering:e?.allowBrokering||t.allowBrokering,trustedBrokerDomains:e?.trustedBrokerDomains||t.trustedBrokerDomains,brokerHandshakeTimeout:e?.brokerHandshakeTimeout||t.brokerHandshakeTimeout,brokerMessageTimeout:e?.brokerMessageTimeout||t.brokerMessageTimeout,brokerInteractionTimeout:e?.brokerInteractionTimeout||t.brokerInteractionTimeout}}class Ie extends x{constructor(e,t,r,s){super(L,r,s),this.version=e,this.correlationId=t}static validate(e){const t=x.validateMessage(e);return t&&t.data&&t.data.version?new Ie(t.data.version,t.data.correlationId,t.data.channelId||e.data.sessionId,t.data.messageId):null}}var Ce=r(388e3),fe=r(224003);function Re(e,t,r){try{switch(e.cache?.temporaryCacheLocation){case B.Al.LocalStorage:return new p.D(e.auth.clientId,t,r);case B.Al.MemoryStorage:return new Ce.X;default:return new fe.u}}catch(e){return new Ce.X}}function Se(e){return`msal.request.${e}`}const ve="4.15.0";function Be(e){const t=e.split("-",1)[0].split(".",3);return{major:parseInt(t[0]),minor:parseInt(t[1]),patch:parseInt(t[2])}}function Ae(e){e.port1.close(),e.port2.close()}function we(e,t,r,s=20){if(0===e.length||r>s)return[0,r-1];let i=r,n=e.length;for(let o=0;o<e.length;o++){e[o].postMessage(t,"*");const[a,d]=we(e[o],t,r+1,s);n+=a,d>i&&(i=d)}return[n,i]}const{invoke:Ee,invokeAsync:ye}=l;function Te(e){return`${e.clientId}-${e.origin}`}class qe extends R{constructor(e,t,r){super(e),this.currentBrokerRedirectResponse=void 0,this.hybridAuthPromise=void 0,this.pwbBrokerAppConfiguration=be(t),this.redirectResponseMap=new Map,this.embeddedAppConfigMap=new Map,this.telemetryAllowedEmbeddedClients=new Set,this.logger=new S.V(e.system?.loggerOptions||{},"@azure/msal-browser-1p",ve),this.tempCache=Re(e,this.logger,this.performanceClient),this.eventHandler=r,this.messageListener=this.handleBrokerMessage.bind(this),this.isListening=!1,this.parentBrokerOrigins=new Set,this.isBroker=!0}getRedirectCorrelationId(){const e=`msal.${this.getConfiguration().auth.clientId}`,t=this.tempCache.getItem(`${e}.request.native`);try{if(t){const e=JSON.parse(t);return e&&"object"==typeof e?e.correlationId:null}}catch(e){this.logger.error("BrokerClientApplication.getRedirectCorrelationId: Unable to parse native request")}return this.tempCache.getItem(`${e}.request.correlationId`)||""}async handleRedirectPromise(e){const t=this.getRedirectCorrelationId(),r=this.performanceClient.startMeasurement(c.AcquireTokenByBroker,t);r.add({brokerEventName:c.AcquireTokenRedirect});try{const t=super.handleRedirectPromise(e);this.currentBrokerRedirectResponse=t;const s=await this.currentBrokerRedirectResponse;if(this.currentBrokerRedirectResponse=void 0,s){const e=function(e){if(!e)return null;try{const t=window.atob(e),r=new Uint8Array(t.length);for(let e=0;e<r.length;e++)r[e]=t.charCodeAt(e);const s=(new TextDecoder).decode(r),i=JSON.parse(s);return i.hasOwnProperty("brokerState")?i:null}catch(e){return null}}(s.state);if(this.setActiveAccount(s.account),!e)return r.end({success:!0}),s;{const t={...s,state:e.userState};this.redirectResponseMap.set(Te({clientId:e.brokerState.requestClientId,origin:e.brokerState.requestOrigin}),t),r.add({embeddedClientId:e.brokerState.requestClientId,embeddedRedirectUri:e.brokerState.requestOrigin}),this.endBrokerPerformanceEvent(e.brokerState.requestClientId,r)}}else r.discard();return null}catch(e){throw e instanceof v.lR&&e.setCorrelationId(t),r.end({success:!1},e),e}}async listenForBrokerMessage(e,t){return this.logger.verbose("listening for child broker messages."),window.addEventListener("message",this.messageListener),this.broadcastBrokerReadyMessage(window.frames,e,t),this.isListening=!0,e&&e.codeRequest&&(this.hybridAuthPromise=this.acquireTokenByCode(e.codeRequest)),this.hybridAuthPromise}broadcastBrokerReadyMessage(e,t,r){const s={messageType:E,channelId:this.channelId,messageId:l.createGuid()};this.logger.trace(`Broadcasting broker ready message ${s.messageId} to child frames.`),window.postMessage(s,"*");const[i,n]=Ee(we,c.PostMessageToAllDescendantFrames,this.logger,this.performanceClient,r?.event.correlationId)(e,s,1,t?.maxChildFrameDepth);r?.add({maxFrameDepthReached:n,framesNotified:i,maxFrameDepthConfigured:t?.maxChildFrameDepth,messageId:s.messageId}),this.logger.trace(`Broadcasted broker ready message to ${i} child frames with a max depth of ${n}`)}stopListeningForBrokerMessage(){this.logger.verbose("stop listening for child broker messages."),window.removeEventListener("message",this.messageListener),this.isListening=!1,this.embeddedAppConfigMap.forEach((([e,t])=>{this.logger.verbose(`closing message port for ${e}`),t.close()})),this.embeddedAppConfigMap.clear()}async handleBrokerMessage(e){const t=x.validateMessage(e);if(t&&t.data.messageType)switch(this.logger.verbose(`Broker received message with type: ${t.data.messageType}`),t.data.messageType){case E:return this.logger.warning("Multiple running brokers are detected in the frame tree. This is an unsupported configuration for your application."),void this.parentBrokerOrigins.add(t.origin);case y:return this.handleBrokerHandshake(t);case P:const e=me.validate(t);if(!e)return;return this.handleBrokerRedirectResponse(e,t);case q:const r=G.validate(t,this.embeddedAppConfigMap.get(t.data.channelId||t.data.sessionId||t.data.embeddedClientId)?.[0]||t.origin);if(!r)return;r.request.correlationId||(r.request.correlationId=l.createGuid());const s=this.performanceClient.startMeasurement(c.AcquireTokenByBroker,r.request.correlationId);s.add({embeddedSessionId:r.channelId}),this.parentBrokerOrigins.size>0&&s.add({parentBrokerCount:this.parentBrokerOrigins.size});const i=t.ports?.[0];try{const e=await ye(this.handleBrokerAuthRequest.bind(this),c.HandleBrokerAuthRequest,this.logger,this.performanceClient,r.request.correlationId)(r,i);if(e?.errorPayload){const{errorCode:t,errorMessage:i,subError:n}={...e.errorPayload};return void this.endBrokerPerformanceEvent(r.embeddedClientId,s,new v.lR(t,i,n))}return void this.endBrokerPerformanceEvent(r.embeddedClientId,s)}catch(e){throw this.endBrokerPerformanceEvent(r.embeddedClientId,s,e),e}default:return}}isDescendantFrame(e){const t=[];for(t.push(e.sourceFrame);t.length>0;){const r=t.pop();if(r)for(let s=0;s<r.frames.length;s++){const i=r.frames[s];if(i===e.targetFrame)return!0;i!==r&&t.push(i)}}return!1}async handleBrokerHandshake(e){if(!e.source||!e.source.window||e.source.window!==e.source)return void this.logger.warning("Broker handshake request validation failed. Message origin is not an iframe");const t=e.source;window===t||this.isDescendantFrame({sourceFrame:window,targetFrame:t})||this.logger.warning("Broker handshake request validation failed. Message origin is not a descendant iframe");const r=Q.validate(e);if(!r)return void this.logger.warning("Broker handshake request validation failed. Message may not have come from MSAL.js.");const s=l.createGuid(),i=this.performanceClient.startMeasurement(c.BrokerClientApplicationHandleBrokerHandshake,s);try{if(i.add({embeddedClientId:r.embeddedClientId,embeddedSessionId:r.channelId,messageId:r.messageId}),r.allowTelemetry&&this.telemetryAllowedEmbeddedClients.add(r.embeddedClientId),this.logger.verbose(`${r.messageType} validated for AppId: ${r.embeddedClientId}`),this.hybridAuthPromise)try{await this.hybridAuthPromise}catch(e){this.logger.error(`Broker could not obtain tokens using authorization code initializer: ${e}`)}const t=new K(ve,"",this.channelId,r.messageId,e.data.nonce);this.logger.verbose(`Sending handshake response to ${e.origin}`);const s=e.ports?.[0];s&&(s.onmessage=this.messageListener,this.embeddedAppConfigMap.set(r.channelId||r.embeddedClientId,[e.origin,s]));const n=Be(e.data.version);s&&3===n.major&&n.minor>=15&&n.minor<=19?s?.postMessage(t):e.source?.postMessage(t,e.origin)}catch(e){throw this.endBrokerPerformanceEvent(r.embeddedClientId,i,e),e}}async handleBrokerRedirectResponse(e,t){if(e){const r=this.embeddedAppConfigMap.get(e.channelId||e.embeddedClientId);let s,i;r?[i,s]=r:(i=t.origin,s=t.ports?.[0]),this.currentBrokerRedirectResponse&&await this.currentBrokerRedirectResponse;const n=this.redirectResponseMap.get(Te({clientId:e.embeddedClientId,origin:i})),o=new ge(B.X8.Redirect,n||null,this.channelId,e.messageId);this.logger.verbose("Sending auth response"),s?.postMessage(o),n?.correlationId&&this.performanceClient.addFields({messageId:e.messageId},n.correlationId);const a=`msal.${this.getConfiguration().auth.clientId}`;this.tempCache.removeItem(`${a}.request.native`)}else;}async handleBrokerAuthRequest(e,t){this.currentBrokerRedirectResponse&&await this.currentBrokerRedirectResponse,e.request.correlationId||(e.request.correlationId=l.createGuid());const r=e.request.correlationId,s=e.request.account||this.getActiveAccount();let i;switch(this.performanceClient.addFields({messageId:e.messageId},r),e.interactionType){case B.X8.Silent:if(s){this.performanceClient.addFields({brokerEventName:c.AcquireTokenSilent},r),i=Ee(this.brokeredSilentRequest.bind(this),c.BrokeredSilentRequest,this.logger,this.performanceClient,r)(e,s,t);break}this.performanceClient.addFields({brokerEventName:c.SsoSilent},r),i=Ee(this.brokeredSsoSilentRequest.bind(this),c.BrokeredSsoSilentRequest,this.logger,this.performanceClient,r)(e,t);break;case B.X8.Redirect:case B.X8.Popup:default:const n=this.getInteractionType(e.interactionType);this.performanceClient.addFields({brokerEventName:n===B.X8.Redirect?c.AcquireTokenRedirect:c.AcquireTokenPopup},r),i=Ee(this.interactiveBrokerRequest.bind(this),c.InteractiveBrokerRequest,this.logger,this.performanceClient,r)(n,e,t)}return i}getInteractionType(e){const t=this.pwbBrokerAppConfiguration.preferredInteractionType;return t||e}async interactiveBrokerRequest(e,t,r){switch(e){case B.X8.Redirect:return Ee(this.brokeredRedirectRequest.bind(this),c.BrokeredRedirectRequest,this.logger,this.performanceClient,t.request.correlationId)(t,r);case B.X8.Popup:return Ee(this.brokeredPopupRequest.bind(this),c.BrokeredPopupRequest,this.logger,this.performanceClient,t.request.correlationId)(t,r);case B.X8.Silent:return void this.logger.error("Invalid code path. interactiveBrokerRequest() should only be called for interactive requests.");case B.X8.None:return void this.logger.error("Broker is blocking interactive requests. Please attempt a silent request or sign into the broker first.");default:return void this.logger.error("Invalid code path. interactiveBrokerRequest() should only be called for interactive requests.")}}async brokeredRedirectRequest(e,t){this.logger.verbose("Brokered redirect request initiated.");const r=this.getAllAccounts();this.eventHandler.emitEvent(0===r.length?A.B.LOGIN_START:A.B.ACQUIRE_TOKEN_START,B.X8.Redirect,e.request);const s=this.embeddedAppConfigMap.get(e.channelId||e.embeddedClientId)?.[1]||t;try{const t=new j(this.channelId,e.messageId);s?.postMessage(t),this.logger.verbose(`Sending redirect response: ${JSON.stringify(t)}`);const r=this.addBrokerRequestProperties(e);return r.state=function(e,t){const r={userState:t,brokerState:{requestOrigin:e.embeddedAppOrigin,requestClientId:e.embeddedClientId}},s=JSON.stringify(r),i=(new TextEncoder).encode(s);return window.btoa(Array.from(i,(e=>String.fromCodePoint(e))).join(""))}(e,r.state),await super.acquireTokenRedirect(r)}catch(t){const i=new ge(B.X8.Redirect,null,this.channelId,e.messageId,t);return this.logger.verbose(`Found auth error in redirect: ${t}`),s?.postMessage(i),this.eventHandler.emitEvent(0===r.length?A.B.LOGIN_FAILURE:A.B.ACQUIRE_TOKEN_FAILURE,B.X8.Redirect,null,t),i}}async brokeredPopupRequest(e,t){this.logger.verbose("Brokered popup request initiated.");const r=this.getAllAccounts();this.eventHandler.emitEvent(0===r.length?A.B.LOGIN_START:A.B.ACQUIRE_TOKEN_START,B.X8.Popup,e.request);const s=this.embeddedAppConfigMap.get(e.channelId||e.embeddedClientId)?.[1]||t;try{const t=this.addBrokerRequestProperties(e),i=await super.acquireTokenPopup(t),n=new ge(B.X8.Popup,i,this.channelId,e.messageId);this.logger.verbosePii("Sending auth response"),s?.postMessage(n);const o=r.length<this.getAllAccounts().length;return this.eventHandler.emitEvent(o?A.B.LOGIN_SUCCESS:A.B.ACQUIRE_TOKEN_SUCCESS,B.X8.Popup,i),n}catch(t){const i=new ge(B.X8.Popup,null,this.channelId,e.messageId,t);return this.logger.verbose(`Found auth error in popup: ${t}`),s?.postMessage(i),this.eventHandler.emitEvent(0===r.length?A.B.LOGIN_FAILURE:A.B.ACQUIRE_TOKEN_FAILURE,B.X8.Popup,null,t),i}}async brokeredSsoSilentRequest(e,t){this.logger.verbose("Brokered SSO Silent request initiated."),this.eventHandler.emitEvent(A.B.SSO_SILENT_START,B.X8.Silent,e.request);const r=this.embeddedAppConfigMap.get(e.channelId||e.embeddedClientId)?.[1]||t;try{const t=this.addBrokerRequestProperties(e),s=await super.ssoSilent(t),i=new ge(B.X8.Silent,s,this.channelId,e.messageId);return this.logger.verbosePii("Sending auth response"),r?.postMessage(i),this.eventHandler.emitEvent(A.B.SSO_SILENT_SUCCESS,B.X8.Silent,s),i}catch(t){const s=new ge(B.X8.Silent,null,this.channelId,e.messageId,t);return this.logger.verbose(`Found auth error in ssoSilent: ${t}`),r?.postMessage(s),this.eventHandler.emitEvent(A.B.SSO_SILENT_FAILURE,B.X8.Silent,null,t),s}}async brokeredSilentRequest(e,t,r){this.logger.verbose("Brokered Silent request initiated."),this.eventHandler.emitEvent(A.B.ACQUIRE_TOKEN_START,B.X8.Silent,e.request);const s=this.embeddedAppConfigMap.get(e.channelId||e.embeddedClientId)?.[1]||r;try{const r=this.addBrokerRequestProperties(e,t);r.cacheLookupPolicy=B.nN.RefreshTokenAndNetwork;const i=await super.acquireTokenSilent(r),n=new ge(B.X8.Silent,i,this.channelId,e.messageId);return s?.postMessage(n),this.eventHandler.emitEvent(A.B.ACQUIRE_TOKEN_SUCCESS,B.X8.Silent,i),n}catch(t){const r=new ge(B.X8.Silent,null,this.channelId,e.messageId,t);return this.logger.verbose(`Found auth error in silent: ${t}`),s?.postMessage(r),this.eventHandler.emitEvent(A.B.ACQUIRE_TOKEN_FAILURE,B.X8.Silent,null,t),r}}getEmbeddedAppRedirectUri(e){const t=new w.H(e);return`brk-${this.getConfiguration().auth.clientId}://${t.getUrlComponents().HostNameAndPort}`}addBrokerRequestProperties(e,t){const r={...e.request};r.redirectUri=this.getEmbeddedAppRedirectUri(e.embeddedAppOrigin),r.embeddedClientId=e.embeddedClientId,r.storeInCache={idToken:!1,accessToken:!1};const s=t||this.getActiveAccount();return s&&(r.account=s),e.request.correlationId&&this.performanceClient.addFields({embeddedClientId:e.embeddedClientId,embeddedRedirectUri:e.embeddedAppOrigin},e.request.correlationId),r}async sendLogoutRequestToEmbeddedApps(e){this.logger.verbose("sendLogoutRequestToEmbeddedApps called"),await this.messageEmbeddedAppsToLogout(new Ie(ve,e?.correlationId||l.createGuid(),this.channelId,l.createGuid()))}async messageEmbeddedAppsToLogout(e){const t=[];this.embeddedAppConfigMap.forEach((r=>{t.push(new Promise(((t,s)=>{const i=window.setTimeout((()=>{t()}),200);try{r[1]?.postMessage(e),r[1].addEventListener("message",(e=>{e.data.messageType===H&&(this.logger.info(`Received logout response from embedded app: ${e.data.embeddedClientId}`),t(),clearTimeout(i))}))}catch(e){this.logger.error(`Could not logout application ${r[0]}. Error in message channel: ${e}`),s(e)}})))})),await Promise.all(t)}endBrokerPerformanceEvent(e,t,r){this.telemetryAllowedEmbeddedClients.has(e)||(this.logger.verbosePii(`TelemetryReporter: Skipping brokered event as not allowed by the client ${e}`,t.event.correlationId),t.discard()),r?t.end({success:!1},r):t.end({success:!0})}}var Me=r(593744),Pe=r(745960);class _e extends x{constructor(e,t,r,s,i){super(H,s,i),this.version=e,this.correlationId=r,this.embeddedClientId=t}}const{invoke:Le,invokeAsync:He}=l;class Oe{constructor(e,t,r,s,i,n,o,a,d,l){this.pwbBrokeredAppConfiguration=r,this.clientId=e,this.logger=s,this.brokerMetadata=null,this.performanceClient=i,this.eventHandler=n,this.hydrateCache=a,this.clearCache=d,this.messageChannelList=[],this.messageChannel=new MessageChannel,this.resolvers=new Map,this.temporaryBrokerStorage=o,this.onWindowMessageCb=this.onWindowMessage.bind(this),this.handshake={correlationId:t,inFlight:!1,wait:Promise.resolve(),resolve:()=>{},reject:()=>{}},this.channelId=l}async isBrokerConnected(){return this.handshake.inFlight&&await this.handshake.wait.catch((e=>{const t=e;this.logger.error(t.message)})),!!this.brokerMetadata}setHandshakeReference(e){this.handshake.performanceEvent=e;const t=()=>{this.handshake.performanceEvent?.add({brokerHandshakeTimeoutMs:this.pwbBrokeredAppConfiguration.brokerHandshakeTimeout}),this.handshake.reject(pe(ne))};if(this.handshake.inFlight)return clearTimeout(this.handshake.timeoutId),void(this.handshake.timeoutId=setTimeout(t,this.pwbBrokeredAppConfiguration.brokerHandshakeTimeout));this.handshake.inFlight=!0,this.handshake.wait=new Promise(((e,r)=>{this.handshake.timeoutId=setTimeout(t,this.pwbBrokeredAppConfiguration.brokerHandshakeTimeout),this.handshake.resolve=e,this.handshake.reject=r})).then((()=>{this.resolvers.forEach((e=>{clearTimeout(e.timeoutId),e.reject(pe(le))})),this.resolvers.clear(),this.eventHandler.emitEvent(A.B.BROKER_CONNECTION_ESTABLISHED,void 0,{pairwiseBrokerOrigin:this.brokerMetadata?.origin||""}),this.handshake.performanceEvent?.end({success:!0})})).catch((e=>{const t=e;throw this.logger.error(t.message),this.handshake.performanceEvent?.end({success:!1},t),e})).finally((()=>{this.handshake.inFlight=!1}))}getAncestors(){const e=[];let t=window;for(;t&&t.parent&&t.parent.window!==t;)t=t.parent?.window,e.push(t);return this.logger.verbose(`Attempting to send handshake request to ${e.length} ancestors`),e}async initiateHandshake(e){if(0===this.pwbBrokeredAppConfiguration.trustedBrokerDomains.length)throw pe(ae);const t=l.createGuid();e?.add({messageId:t});try{this.setHandshakeReference(e),window.addEventListener("message",this.onWindowMessageCb);const r=[];r.push(window),r.push(...this.getAncestors());for(let s=0;s<r.length;s++){const i=r[s],n=r.length-s-1;this.logger.verbose(`Sending handshake request to frame with depth = ${n}`),Le(this.sendHandshakeRequest.bind(this),c.SendHandshakeRequest,this.logger,this.performanceClient,e?.event.correlationId)(i,n,t,void 0,e)}await this.isBrokerConnected()}catch(e){const t=e;this.logger.error(t.message)}}async onWindowMessage(e){try{if(e.data&&e.origin&&this.pwbBrokeredAppConfiguration.trustedBrokerDomains.includes(e.origin)){if(e.data.messageType===E){this.logger.verbose("Broker is available."),this.handshake.performanceEvent?.discard();const t=this.performanceClient.startMeasurement(c.PairwiseBrokerApplicationInitializeBrokering,this.handshake.correlationId),r=e.data.messageId;t.add({isBackground:!0,messageId:r}),e.origin===this.brokerMetadata?.origin&&(this.brokerMetadata=null,Ae(this.messageChannel)),this.setHandshakeReference(t);const s=Le(this.getFrameDepth.bind(this),c.GetFrameDepth,this.logger,this.performanceClient,this.handshake.correlationId)(e.source);return Le(this.sendHandshakeRequest.bind(this),c.SendHandshakeRequest,this.logger,this.performanceClient,this.handshake.correlationId)(e.source,s,r,e.origin,t)}e.data.messageType===T&&this.onHandshakeResponse(e)}}catch(e){const t=e;this.logger.error(t.message)}}getFrameDepth(e){const t=[];t.push(window),t.push(...this.getAncestors());for(let r=0;r<t.length;r++){if(t[r]===e)return t.length-r-1}return 0}closeBrokerConnection(){this.logger.verbose("Closing broker connection."),this.brokerMetadata=null,Ae(this.messageChannel),this.messageChannelList.forEach((e=>Ae(e.channel))),window.removeEventListener("message",this.onWindowMessageCb)}async sendSsoSilentRequest(e){const t=this.performanceClient.startMeasurement(c.EmbeddedClientApplicationSendSSOSilentRequest,e.correlationId);l.preflightCheck(!0),t.increment({visibilityChangeCount:0});const r=()=>{this.trackPageVisibility(e.correlationId)};document.addEventListener("visibilitychange",r);try{const r=await He(this.sendRequest.bind(this),c.SendRequest,this.logger,this.performanceClient,e.correlationId)(e,B.X8.Silent),s=await He(this.handleResponse.bind(this),c.HandleResponse,this.logger,this.performanceClient,e.correlationId)(r,e);if(!s)throw this.logger.errorPii(`Broker response is empty in brokered ssoSilent request: ${JSON.stringify(s)}`),pe(re);return t.end({success:!0,fromCache:s.fromCache,accessTokenSize:s.accessToken.length,idTokenSize:s.idToken.length,isNativeBroker:s.fromNativeBroker,requestId:s.requestId},e.correlationId),s}catch(e){throw t.end({success:!1},e),e}finally{document.removeEventListener("visibilitychange",r)}}async sendPopupRequest(e){const t=this.performanceClient.startMeasurement(c.EmbeddedClientApplicationSendPopupRequest,e.correlationId);l.preflightCheck(!0);try{const r=await He(this.sendRequest.bind(this),c.SendRequest,this.logger,this.performanceClient,e.correlationId)(e,B.X8.Popup),s=await He(this.handleResponse.bind(this),c.HandleResponse,this.logger,this.performanceClient,e.correlationId)(r,e);if(!s){if(!j.validate(r))throw this.logger.errorPii(`Broker response is empty in brokered popup request: ${JSON.stringify(s)}`),pe(re);throw this.logger.verbose("popupRequest requires a redirect by the broker, this app will now redirect."),pe(se)}return t.end({success:!0,fromCache:s.fromCache,accessTokenSize:s.accessToken.length,idTokenSize:s.idToken.length,isNativeBroker:s.fromNativeBroker,requestId:s.requestId}),s}catch(e){throw t.end({success:!1},e),e}}async sendHandleRedirectRequest(e){const t=this.performanceClient.startMeasurement(c.EmbeddedClientApplicationHandleRedirectRequest,e.correlationId);try{const r=new me(this.clientId,ve,this.channelId,l.createGuid()),s=await He(this.messageBroker.bind(this),c.SendMessageToBroker,this.logger,this.performanceClient,e.correlationId)(r,e.correlationId).catch((t=>{if(t instanceof ue&&t.errorCode===le)return this.performanceClient.addFields({brokerConnReset:!0},e.correlationId),He(this.messageBroker.bind(this),c.SendMessageToBroker,this.logger,this.performanceClient,e.correlationId)(r,e.correlationId);throw t}));t.add({brokerSessionId:s?.data?.channelId||s?.data?.sessionId});const i=await He(this.handleResponse.bind(this),c.HandleResponse,this.logger,this.performanceClient,e.correlationId)(s,e);return t.end({success:!0,fromCache:i?.fromCache,accessTokenSize:i?.accessToken.length,idTokenSize:i?.idToken.length,isNativeBroker:i?.fromNativeBroker}),i}catch(e){throw t.end({success:!1},e),e}}async sendSilentRefreshRequest(e){l.preflightCheck(!0),this.performanceClient.incrementFields({visibilityChangeCount:0},e.correlationId);const t=()=>this.trackPageVisibility(e.correlationId);document.addEventListener("visibilitychange",t);try{const t=await He(this.sendRequest.bind(this),c.SendRequest,this.logger,this.performanceClient,e.correlationId)(e,B.X8.Silent),r=await He(this.handleResponse.bind(this),c.HandleResponse,this.logger,this.performanceClient,e.correlationId)(t,e);if(!r)throw this.logger.errorPii(`Broker response is empty in brokered silent refresh request: ${JSON.stringify(r)}`),pe(re);return this.performanceClient.addFields({fromCache:r.fromCache,accessTokenSize:r.accessToken.length,idTokenSize:r.idToken.length,isNativeBroker:r.fromNativeBroker,requestId:r.requestId},e.correlationId),r}finally{document.removeEventListener("visibilitychange",t)}}async sendRequest(e,t){if(e.authenticationScheme===Me.IO.POP){const t=new Pe.a(e);e.popKid=await t.generatePublicKeyThumbprint();const r=Se(this.clientId);this.temporaryBrokerStorage.containsKey(r)&&this.temporaryBrokerStorage.setItem(r,JSON.stringify(e))}const r=new G(this.clientId,t,e,"",this.channelId,l.createGuid());return He(this.messageBroker.bind(this),c.SendMessageToBroker,this.logger,this.performanceClient,e.correlationId)(r,e.correlationId).catch((t=>{if(t instanceof ue&&t.errorCode===le)return He(this.messageBroker.bind(this),c.SendMessageToBroker,this.logger,this.performanceClient,e.correlationId)(r,e.correlationId);throw t}))}getMessageChannelProperties(e){return e?this.messageChannelList.find((t=>t.nonce===e)):this.getMessageChannelPropertiesByDepth(0)}getMessageChannelPropertiesByDepth(e){return this.messageChannelList.find((t=>t.depth===e))}onHandshakeResponse(e){const t=this.handshake.performanceEvent;try{const r=K.validate(e,this.pwbBrokeredAppConfiguration.trustedBrokerDomains);if(r){const e=this.getMessageChannelProperties(r.nonce);if(!e)return this.logger.trace("No MessageChannel found, ignoring this response"),void t?.increment({handshakeIgnoredCount:1});if(r.nonce&&r.nonce!==e.nonce)return this.logger.trace("Received handshake response but there is a newer handshake request in flight, ignoring this one"),void t?.increment({handshakeIgnoredCount:1});this.handshake.timeoutId&&clearTimeout(this.handshake.timeoutId),this.logger.verbose("Received handshake response");const s=Be(r.version);s.major<=3&&s.minor<15&&Ae(e.channel),Ae(this.messageChannel),this.messageChannel=e.channel,this.brokerMetadata={origin:r.brokerOrigin,version:r.version,semver:s,frameDepth:e.depth,supportsMessageId:!!r.messageId},t?.add({brokerFrameDepth:e.depth,brokerSessionId:r.channelId}),this.handshake.resolve()}}catch(e){this.handshake.reject(e)}}sendHandshakeRequest(e=window.top,t,r,s,i){if(this.logger.trace("Pairwise Broker - sendHandshakeRequest called."),!e)throw this.logger.error("Target frame is undefined."),pe(oe);let n=new MessageChannel;const o=l.createGuid();n.port1.onmessage=async t=>{t.data&&(t.data.messageType===T?(this.logger.warning("Received handshake response but the broker app is using a version of MSAL.js that does not report its origin, attempting direct communication with each trusted broker domain to resolve. This is a known issue with versions 3.15.0-3.19.1, consider asking the broker app to upgrade."),this.pwbBrokeredAppConfiguration.trustedBrokerDomains.forEach((t=>{const r=new MessageChannel;r.port1.onmessage=e=>(Ae(n),n=r,Le(this.onHandshakeResponse.bind(this),c.OnHandshakeResponse,this.logger,this.performanceClient,i?.event.correlationId)({...e,data:{...e.data},origin:t})),this.logger.verbose(`Sending handshake request to ${t}`),e?.postMessage(a,t,[r.port2])}))):await He(this.handleBrokerMessage.bind(this),c.HandleBrokerMessage,this.logger,this.performanceClient,i?.event.correlationId)(t))};const a=new Q(this.clientId,ve,!0,this.channelId,r,o),d=this.getMessageChannelPropertiesByDepth(t);d?(Ae(d.channel),d.channel=n,d.nonce=o):this.messageChannelList.push({channel:n,nonce:o,depth:t}),this.logger.verbose("Sending handshake request"),i?.increment({handshakeSentCount:1}),e?.postMessage(a,s||"*",[n.port2])}async handleBrokerMessage(e){const t=e.data.messageType;if(this.logger.verbose(`Received message from broker of type: ${t}`),!t||t===M)return;const r=e.data?.result?.correlationId||e.data?.errorPayload?.correlationId;if(t===L)return this.logger.verbose("Received logout message from broker."),await this.handleLogoutMessageFromBroker(e),void this.messageChannel.port1.postMessage(new _e(ve,this.clientId,r,this.channelId,e.data.messageId));const s=this.brokerMetadata?.supportsMessageId?e.data.messageId:t===_&&e.data.interactionType===B.X8.Redirect?B.X8.Redirect:r;if(!s)return this.logger.verbose(`No embedded embedded request id or correlation id found in message: ${t}.`),void this.performanceClient.incrementFields({resolverKeyMissingCount:1},r);this.logger.verbose(`Received response of type ${t} and key ${s} from broker.`);const i=this.resolvers.get(s);i?(clearTimeout(i.timeoutId),i.resolve(e),this.resolvers.delete(s)):(this.logger.warning(`Cannot resolve message for ${s}. Ignoring.`),this.performanceClient.incrementFields({resolverKeyNotExistCount:1},r))}async messageBroker(e,t){return new Promise(((r,s)=>{if(!this.brokerMetadata)return void s(pe(de));let i=this.pwbBrokeredAppConfiguration.brokerMessageTimeout;const n={};e.interactionType===B.X8.Popup?(n.brokerInteractionTimeoutMs=this.pwbBrokeredAppConfiguration.brokerInteractionTimeout,i=this.pwbBrokeredAppConfiguration.brokerInteractionTimeout):n.brokerMessageTimeoutMs=this.pwbBrokeredAppConfiguration.brokerMessageTimeout,this.performanceClient.addFields(n,t);const o=setTimeout((()=>{s(pe(ie))}),i),a=this.brokerMetadata.supportsMessageId?e.messageId:e.messageType===P?B.X8.Redirect:t;if(this.resolvers.set(a,{resolve:r,reject:s,timeoutId:o}),this.brokerMetadata.semver.major>3||3===this.brokerMetadata.semver.major&&this.brokerMetadata.semver.minor>=15)this.messageChannel.port1.postMessage(e);else{const t=new MessageChannel;t.port1.onmessage=this.handleBrokerMessage.bind(this),window.top?.postMessage(e,this.brokerMetadata.origin,[t.port2])}}))}async handleResponse(e,t){const r=ge.validate(e);if(!r)return null;if(t.correlationId&&this.performanceClient.addFields({brokerSessionId:r.channelId},t.correlationId),r.errorPayload)throw ge.detectError(r.errorPayload);if(!r.result)throw pe(re);let s;if(await this.hydrateCache(r.result,t),t.authenticationScheme===Me.IO.POP){if(!t.popKid)throw pe(ce);const e=new Pe.a(t);s=await e.signRequest(r.result.accessToken,t.popKid)}return{...r.result,accessToken:s||r.result.accessToken,pairwiseBrokerOrigin:this.brokerMetadata?.origin}}async handleLogoutMessageFromBroker(e){Ie.validate(e)&&(this.logger.verbose("Logout request received from broker and validated. Logging out embedded app."),await this.clearCache())}trackPageVisibility(e){this.logger.info("Embedded client: Visibility change detected"),this.performanceClient.incrementFields({visibilityChangeCount:1},e)}}var Ne=r(642026),Fe=r(206809);const{invokeAsync:Ue}=l;class De extends R{constructor(e,t,r){super(e,r),this.pwbBrokerAppConfig=be(t),this.temporaryBrokerStorage=Re(e,this.getLogger(),this.performanceClient),this.eventHandler=new Ne.J(this.getLogger()),this.redirectResponse=new Map,this.initialized=!1}async initialize(e){await super.initialize(e),this.initialized=!0}async initializeBrokering(e,t){if("undefined"==typeof window)return;const r={...t,correlationId:t?.correlationId||l.createGuid()},s=this.performanceClient.startMeasurement(c.PairwiseBrokerApplicationInitializeBrokering,r.correlationId);s.add({isBackground:!1});try{this.pwbBrokerAppConfig.actAsBroker?(this.pwbBrokerAppConfig.allowBrokering&&this.getLogger().verbose("Running in top frame and both actAsBroker, allowBrokering flags set to true. actAsBroker takes precedence."),s.add({isBroker:!0}),this.broker||(this.getLogger().verbose("Acting as Broker"),this.broker=new qe(this.getConfiguration(),this.pwbBrokerAppConfig,this.eventHandler),await this.broker.initialize(r)),this.broker.isListening?this.getLogger().info("Broker already initialized"):await this.broker.listenForBrokerMessage(e,s),s.end({success:!0})):this.pwbBrokerAppConfig.allowBrokering&&(this.getLogger().verbose("Acting as child"),s.add({isBroker:!1}),this.embeddedApp?await this.embeddedApp.isBrokerConnected()?this.getLogger().info("Embedded app is already connected to the broker"):(this.getLogger().info("initializeBrokering was called again, retrying handshake"),await this.embeddedApp.initiateHandshake(s)):(this.embeddedApp=new Oe(this.getConfiguration().auth.clientId,r.correlationId,this.pwbBrokerAppConfig,this.getLogger(),this.performanceClient,this.eventHandler,this.temporaryBrokerStorage,this.hydrateCache.bind(this),this.clearCache.bind(this),this.channelId),await this.embeddedApp.initiateHandshake(s)))}catch(e){throw s.end({success:!1},e),e}}createEmbeddedRequest(e){const t={...e,correlationId:e.correlationId||l.createGuid()};return t.account||t.sid||t.loginHint||(t.account=this.getActiveAccount()||void 0),t}async handleRedirectPromise(e){if(l.blockAPICallsBeforeInitialize(this.initialized),"undefined"!=typeof window){const t=e||"";let r=this.redirectResponse.get(t);if(void 0===r){this.eventHandler.emitEvent(A.B.HANDLE_REDIRECT_START,B.X8.Redirect);const s=this.getAllAccounts();r=this.handleRedirectPromiseInternal(e).then((e=>{if(!e)return null;const t=s.length<this.getAllAccounts().length;return this.eventHandler.emitEvent(t?A.B.LOGIN_SUCCESS:A.B.ACQUIRE_TOKEN_SUCCESS,B.X8.Redirect,e),e})).catch((e=>{throw this.eventHandler.emitEvent(s.length>0?A.B.ACQUIRE_TOKEN_FAILURE:A.B.LOGIN_FAILURE,B.X8.Redirect,null,e),e})).finally((()=>{this.eventHandler.emitEvent(A.B.HANDLE_REDIRECT_END,B.X8.Redirect)})),this.redirectResponse.set(t,r)}return r}return null}async handleRedirectPromiseInternal(e){if(this.embeddedApp&&await this.embeddedApp.isBrokerConnected()){const e=Se(this.controller.getConfiguration().auth.clientId),t=this.temporaryBrokerStorage.getItem(e);if(t){const r=JSON.parse(t);return await this.embeddedApp.sendHandleRedirectRequest(r).catch((e=>{throw e instanceof v.lR&&e.setCorrelationId(r.correlationId),e})).finally((()=>{this.temporaryBrokerStorage.removeItem(e)}))}return null}return this.broker?this.broker.handleRedirectPromise(e):super.handleRedirectPromise(e)}async loginRedirect(e){return this.acquireTokenRedirect(e||{scopes:Me.aZ})}async acquireTokenRedirect(e){const t=0===this.getAllAccounts().length;return this.eventHandler.emitEvent(t?A.B.LOGIN_START:A.B.ACQUIRE_TOKEN_START,B.X8.Redirect,e),super.acquireTokenRedirect(e).catch((e=>(this.eventHandler.emitEvent(t?A.B.LOGIN_FAILURE:A.B.ACQUIRE_TOKEN_FAILURE,B.X8.Redirect,null,e),Promise.reject(e))))}async loginPopup(e){return this.acquireTokenPopup(e||{scopes:Me.aZ})}async acquireTokenPopup(e){l.preflightCheck(!0);const t=this.createEmbeddedRequest(e),r=this.getAllAccounts();return this.eventHandler.emitEvent(0===r.length?A.B.LOGIN_START:A.B.ACQUIRE_TOKEN_START,B.X8.Popup,t),this.acquireTokenPopupInternal(t).then((e=>{const t=r.length<this.getAllAccounts().length;return this.eventHandler.emitEvent(t?A.B.LOGIN_SUCCESS:A.B.ACQUIRE_TOKEN_SUCCESS,B.X8.Popup,e),e})).catch((e=>{e instanceof v.lR&&e.setCorrelationId(t.correlationId);const s=0===r.length;return this.eventHandler.emitEvent(s?A.B.LOGIN_FAILURE:A.B.ACQUIRE_TOKEN_FAILURE,B.X8.Popup,null,e),Promise.reject(e)}))}async acquireTokenPopupInternal(e){if(this.embeddedApp&&await this.embeddedApp.isBrokerConnected()){this.getLogger().verbose("pairwise broker (embedded app) acquireTokenPopup called",e.correlationId);const t=Se(this.controller.getConfiguration().auth.clientId);this.temporaryBrokerStorage.setItem(t,JSON.stringify(e));return await this.embeddedApp.sendPopupRequest(e).finally((()=>{this.temporaryBrokerStorage.removeItem(t)}))}return super.acquireTokenPopup(e)}async ssoSilent(e){l.preflightCheck(!0);const t=this.createEmbeddedRequest(e);return this.eventHandler.emitEvent(A.B.SSO_SILENT_START,B.X8.Silent,t),this.ssoSilentInternal(t).then((e=>(this.eventHandler.emitEvent(A.B.SSO_SILENT_SUCCESS,B.X8.Silent,e),e))).catch((e=>{throw e instanceof v.lR&&e.setCorrelationId(t.correlationId),this.eventHandler.emitEvent(A.B.SSO_SILENT_FAILURE,B.X8.Silent,null,e),e}))}async ssoSilentInternal(e){return this.embeddedApp&&await this.embeddedApp.isBrokerConnected()?(this.getLogger().verbose("ssoSilent called",e.correlationId),this.embeddedApp.sendSsoSilentRequest(e)):super.ssoSilent(e)}async acquireTokenSilent(e){l.preflightCheck(!0);const t=this.createEmbeddedRequest(e);return this.eventHandler.emitEvent(A.B.ACQUIRE_TOKEN_START,B.X8.Silent,t),this.acquireTokenSilentInternal(t).then((e=>(this.eventHandler.emitEvent(A.B.ACQUIRE_TOKEN_SUCCESS,B.X8.Silent,e),e))).catch((e=>(e instanceof v.lR&&e.setCorrelationId(t.correlationId),this.eventHandler.emitEvent(A.B.ACQUIRE_TOKEN_FAILURE,B.X8.Silent,null,e),Promise.reject(e))))}async acquireTokenSilentInternal(e){if(this.embeddedApp&&await this.embeddedApp.isBrokerConnected()){this.getLogger().verbose("acquireTokenSilent - attempting to acquire token from web flow");const t=this.performanceClient.startMeasurement(c.EmbeddedClientApplicationSendSilentRefreshRequest,e.correlationId);try{const r={...e,cacheLookupPolicy:B.nN.AccessToken};let s;s=e.cacheLookupPolicy===B.nN.RefreshToken||e.cacheLookupPolicy===B.nN.RefreshTokenAndNetwork||e.cacheLookupPolicy===B.nN.Skip||e.forceRefresh?Promise.reject(new W.eB(Fe.tokenRefreshRequired)):super.acquireTokenSilent(r);try{const e=await s;return t.end({success:!0}),e}catch(r){if(e.cacheLookupPolicy===B.nN.AccessToken)throw r;const s=await Ue(this.embeddedApp.sendSilentRefreshRequest.bind(this.embeddedApp),c.EmbeddedSendSilentRefreshRequestInternal,this.getLogger(),this.performanceClient,e.correlationId)(e);return t.end({success:!0}),s}}catch(e){throw t.end({success:!1},e),e}}return super.acquireTokenSilent(e)}async logoutRedirect(e){if(this.embeddedApp&&await this.embeddedApp.isBrokerConnected())this.getLogger().error("Embedded app is not allowed to logout while the broker app is logged in.");else if(this.broker)return await this.broker.sendLogoutRequestToEmbeddedApps(),super.logoutRedirect(e)}async logoutPopup(e){if(this.embeddedApp&&await this.embeddedApp.isBrokerConnected())this.getLogger().error("Embedded app is not allowed to logout while the broker app is logged in.");else if(this.broker)return await this.broker.sendLogoutRequestToEmbeddedApps(),super.logoutPopup(e)}setActiveAccount(e){this.broker&&this.broker.setActiveAccount(e),super.setActiveAccount(e)}addEventCallback(e,t=Object.values(A.B)){const r=[A.B.ACQUIRE_TOKEN_START,A.B.ACQUIRE_TOKEN_SUCCESS,A.B.ACQUIRE_TOKEN_FAILURE,A.B.LOGIN_START,A.B.LOGIN_SUCCESS,A.B.LOGIN_FAILURE,A.B.SSO_SILENT_START,A.B.SSO_SILENT_SUCCESS,A.B.SSO_SILENT_FAILURE,A.B.HANDLE_REDIRECT_START,A.B.HANDLE_REDIRECT_END,A.B.BROKER_CONNECTION_ESTABLISHED],s=[],i=[];t.forEach((e=>{r.includes(e)?s.push(e):i.push(e)}));const n=super.addEventCallback(e,i);return n?(this.eventHandler.addEventCallback(e,s,n),n):null}removeEventCallback(e){super.removeEventCallback(e),this.eventHandler.removeEventCallback(e)}}}}]);
//# sourceMappingURL=vendors~auth-msal-browser-1p.js.map